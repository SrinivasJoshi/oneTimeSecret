# OneTimeSecret (Ephemeral Secret Sharing Service)

This project implements a secure service for sharing text-based secrets ephemerally. It follows a zero-knowledge principle, meaning the server never has access to the plaintext secrets or decryption keys. Secrets are encrypted client-side, stored temporarily on the server, and can only be viewed once within a 1-hour time limit.

## Core Features

* **Client-Side Encryption:** Secrets are encrypted/decrypted directly in the user's browser.
* **Zero-Knowledge Server:** The server only stores encrypted data and cannot decrypt it.
* **View Once:** Secrets are permanently deleted after being successfully viewed once.
* **Time-Limited:** Secrets expire automatically after 1 hour.
* **Secure:** Uses HTTPS, standard security headers (CSP, HSTS etc.), and API rate limiting.

## Tech Stack

* **Backend:** Node.js, Express.js
* **Database:** PostgreSQL
* **Client-Side:** HTML, CSS, JavaScript (Web Crypto API) - *Client code not included in this backend setup*
* **Containerization:** Docker, Docker Compose
* **Testing:** E2E Tests (using Cypress/Playwright - *setup not included here*)

## Setup and Running

1.  **Prerequisites:**
    * Docker Desktop (or Docker Engine + Docker Compose) installed.
    * Node.js (for potential local development/testing outside Docker).

2.  **Environment Variables:**
    * Create a `.env` file in the project root directory by copying `.env.example` (if provided, otherwise create it).
    * Fill in the necessary environment variables, especially if you want to override the defaults in `docker-compose.yml` (e.g., `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`, `PORT`). For basic setup, the defaults might suffice.

3.  **Build and Run with Docker Compose:**
    ```bash
    docker-compose up --build -d
    ```
    * `--build`: Forces Docker to rebuild the backend image if changes were made.
    * `-d`: Runs the containers in detached mode (in the background).

4.  **Accessing the API:**
    * The backend API will be available at `http://localhost:<PORT>` (defaulting to `http://localhost:9000`).

5.  **Stopping the Services:**
    ```bash
    docker-compose down
    ```
    * To remove the persistent database volume as well (use with caution!): `docker-compose down -v`

## API Endpoints

* **`POST /api/secrets`**: Creates a new secret.
    * **Request Body:** `{ "encryptedSecret": "base64-encoded-encrypted-text" }`
    * **Response (Success 201):** `{ "referenceId": "unique-secret-id" }`
    * **Response (Error):** Standard HTTP error codes (e.g., 400, 500).
* **`POST /api/secrets/:id/consume`**: Attempts to validate and consume (view) a secret.
    * **Request Body:** (Empty)
    * **Response (Success 200):** `{ "encryptedSecret": "base64-encoded-encrypted-text" }` - Contains the encrypted secret needed for client-side decryption.
    * **Response (Error 404/410):** If the secret is not found, already viewed, or expired.
    * **Response (Error 429):** If rate limit is exceeded.

## Security Model

The system relies on client-side encryption. The server receives only the encrypted data and a `referenceId`. The decryption key is kept solely within the URL fragment (`#key`) generated by the client, which is never sent to the server. Security depends on the user sharing the full URL securely. The server ensures secrets are view-once and expire after 1 hour.

## Security Analysis & E2E Testing

* A basic threat model and mitigation analysis should be performed and documented separately.
* Comprehensive E2E tests (e.g., using Cypress/Playwright) should be implemented to ensure the core flows work correctly and securely. (Test setup/code not included in this backend scaffold).


## Deployment

1. Securely transfer the deploy.sh script to the target Linux server
```bash
scp deploy.sh user@your_server_ip:/home/user/
``` 
2. Make Executable: SSH into your server and make the script executable:
```Bash
ssh user@your_server_ip
chmod +x deploy.sh
```
3. Run: Execute the script, providing the Git repository URL. Run with sudo if you haven't added your user to the docker group or need root for installations.
```Bash
# Example without sudo (if user is in docker group)
./deploy.sh git@github.com:your_user/your_repo.git

# Example with sudo (for installations)
sudo ./deploy.sh git@github.com:your_user/your_repo.git

# Example with specific branch and directory
sudo ./deploy.sh https://github.com/your_user/your_repo.git develop my_custom_app_dir
```
4. Create .env File: The script will likely pause and exit after cloning if the .env file is missing. cd into the project directory (onetimesecret_app or your custom name), create the .env file using nano .env or vim .env, paste your production environment variables, and save it.
 
5. Re-run or Run Compose: You can either re-run the entire script (it will detect the existing directory and just pull changes) or manually run docker compose up --build -d (or the appropriate command) from within the project directory now that the .env file exists.